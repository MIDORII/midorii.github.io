<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[华为前的小准备]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%8D%8E%E4%B8%BA%E5%89%8D%E7%9A%84%E5%B0%8F%E5%87%86%E5%A4%87%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统的小小集合]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B0%8F%E5%B0%8F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络的小小总结]]></title>
    <url>%2F2019%2F09%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B0%8F%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[手撕代码基础]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一.链表类1.链表基础操作: 123456789101112131415//NODEtype struct Node&#123; int num; struct Node *next;&#125;node;//INSERT p = (LinkList)malloc(sizeof(LNode)); p-&gt;next = x ; p-&gt;next = l-&gt;next; l-&gt;next = p; //DELETE p = L; while() p = p-&gt;next; q = p-&gt;next;p-&gt;next=q-&gt;next; free(q); 2.链表倒置： 12345678LinkNode prev = null;LinkNode next = null;while (node != null)&#123;next = node.next;node.next = prev;prev = node;node = next;&#125;return prev; 3.循环链表: 123456p = head;q = head-&gt;next;while (p!=NULL &amp;&amp;q!=NULL&amp;&amp;q-&gt;next!=NULL&amp;&amp;p!=q) &#123; p = p-&gt;next;//p每次走一步 q = q-&gt;next-&gt;next;//q每次走两步&#125; 4.两个链表的第一个公共节点:遍历两个链表得到它们的长度a、b，在较长链表上先走a-b步，然后一起遍历直到有相同节点。时间复杂度O(m+n)。5.链表快排： 123456789101112131415161718192021pNode* partition(pNode* start,pNode* end)&#123; int num = start-&gt;val; pNode* p = start; pNode* q = start-&gt;next; while(q != end)&#123; if(q-&gt;val &lt; num)&#123; p = p-&gt;next; swap(p-&gt;val,q-&gt;val); &#125; q = q-&gt;next; &#125; swap(p-&gt;val,start-&gt;val); return p;&#125;void quick_sort(pNode* start,pNode* end)&#123; if(start != end)&#123; pNode* index = partition(start,end); quick_sort(start,index); quick_sort(index-&gt;next,end); &#125;&#125; 6.合并两个有序链表： 1234567891011121314151617public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; ListNode head = null; if (l1.val &lt; l2.val) &#123; head = l1; head.next = mergeTwoLists(l1.next, l2); &#125; else &#123; head = l2; head.next = mergeTwoLists(l1, l2.next); &#125; return head;&#125; 二.二叉树类1.找最近公共子节点： 123456789101112public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; //发现目标节点则通过返回值标记该子树发现了某个目标结点 if(root == null || root == p || root == q) return root; //查看左子树中是否有目标结点，没有为null TreeNode left = lowestCommonAncestor(root.left, p, q); //查看右子树是否有目标节点，没有为null TreeNode right = lowestCommonAncestor(root.right, p, q); //都不为空，说明做右子树都有目标结点，则公共祖先就是本身 if(left!=null&amp;&amp;right!=null) return root; //如果发现了目标节点，则继续向上标记为该目标节点 return left == null ? right : left; &#125; 2.非递归的先序、中序、后虚遍历先序： 1234567891011121314151617void preorder(binode* root)&#123; if (root==nullptr) return; binode *p=root; stack&lt;binode*&gt; s; while (p!=nullptr || !s.empty())&#123; while (p!= nullptr)&#123; cout&lt;&lt;p-&gt;val; s.push(p); p=p-&gt;left; &#125; if (!s.empty())&#123; p=s.top(); s.pop(); p=p-&gt;right; &#125; &#125;&#125; 中序： 1234567891011121314151617void midorder(binode* root)&#123; if (root==nullptr) return; binode *p=root; stack&lt;binode*&gt; s; while (p!=nullptr || !s.empty())&#123; while (p!= nullptr)&#123; s.push(p); p=p-&gt;left; &#125; if (!s.empty())&#123; p=s.top(); cout&lt;&lt;p-&gt;val; s.pop(); p=p-&gt;right; &#125; &#125;&#125; 后序： 1234567891011121314151617181920212223void postorder(binode* root)&#123; if (root==nullptr) return; binode *p=root; stack&lt;binode*&gt; s; stack&lt;binode*&gt; t; while (p!=nullptr || !s.empty())&#123; while (p!= nullptr)&#123; s.push(p); t.push(p); p=p-&gt;right; &#125; if (!s.empty())&#123; p=s.top(); s.pop(); p=p-&gt;left; &#125; &#125; while (!t.empty()) &#123; p=t.top(); t.pop(); cout&lt;&lt;p-&gt;val; &#125;&#125; 3.二叉树层次遍历： 123456789101112131415161718void layerorder(binode* root)&#123; if(root== nullptr) return; binode* p; queue&lt;binode*&gt; q; q.push(root); while (!q.empty())&#123; p = q.front(); q.pop(); cout&lt;&lt;p-&gt;val; if(p-&gt;left!= nullptr)&#123; q.push(p-&gt;left); &#125; if(p-&gt;right!= nullptr)&#123; q.push(p-&gt;right); &#125; &#125;&#125; 4.二叉搜索树中第K小的元素: 1234567891011121314public int kthSmallest(TreeNode root, int k) &#123; int count = countNodes(root.left); if (k &lt;= count) &#123; return kthSmallest(root.left, k); &#125; else if (k &gt; count + 1) &#123; return kthSmallest(root.right, k - 1 - count); &#125; return root.val;&#125;public int countNodes(TreeNode n) &#123; if (n == null) return 0; return 1 + countNodes(n.left) + countNodes(n.right);&#125; 三.排序和查找类1.快排： 1234567891011121314151617void quickSort(vector&lt;int&gt; &amp;num, int l, int r) &#123; if (l &gt;= r) return; int i = l, j = r, x = num[l]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; num[j] &gt;= x)//从右向左找到第一个小于x的 j--; if (i &lt; j) num[i++] = num[j];//填坑之后i++ while (i &lt; j &amp;&amp; num[i] &lt;= x)//从左向右找第一个大于x的数 i++; if (i &lt; j) num[j--] = num[i]; &#125; num[i] = x; //把最开始取出来的x放到i处 quickSort(num, l, i - 1);//以i为中间值，分左右两部分递归调用 quickSort(num, i + 1, r);&#125; 2.归并： 12345678910111213141516171819202122232425262728293031void mergearr(int* a, int begin, int mid, int end, int *temp)&#123;// 归并排序单元使用 int i=begin, j=mid+1; int m = mid, n = end; int k = 0; while (i &lt;= m &amp;&amp; j&lt;= n)&#123; if (a[i]&lt;a[j]) temp[k++]=a[i++]; else temp[k++]=a[j++]; &#125; while (i&lt;=m) temp[k++]=a[i++]; while (j&lt;=n) temp[k++]=a[j++]; for (i=0;i&lt;k;i++)&#123; a[begin+i]=temp[i]; &#125;&#125;void _merge_sort(int* a, int begin, int end, int *temp)&#123;// 归并排序算子 if(begin&lt;end) &#123; int mid = (begin + end) / 2; _merge_sort(a, begin, mid, temp); _merge_sort(a, mid + 1, end, temp); mergearr(a, begin, mid, end,temp); &#125;&#125;int* MergeSort(int *a, int len)&#123;// 归并排序 int *temp = new int[len]; _merge_sort(a,0,len-1,temp); return temp;&#125; 3.堆： 123456789101112131415161718192021222324252627282930void HeapAdjust(int k[],int p,int n)&#123;//大顶堆的构造，传入的i是父节点 int i,temp; temp = k[p]; for (i = 2 * p; i &lt;= n;i*=2) //逐渐去找左右孩子结点 &#123; //找到两个孩子结点中最大的 if (i &lt; n&amp;&amp;k[i] &lt; k[i + 1]) i++; //父节点和孩子最大的进行判断，调整，变为最大堆 if (temp &gt;= k[i]) break; //将父节点数据变为最大的，将原来的数据还是放在temp中， k[p] = k[i]; //若是孩子结点的数据更大，我们会将数据上移，为他插入的点提供位置 p = i; &#125; //当我们在for循环中找到了p子树中，满足条件的点，我们就加入数据到该点p,注意：p点原来数据已经被上移动了，若没有找到，就是相当于对其值不变 //插入 k[p] = temp;&#125;void HeapSort(int k[], int n)&#123;//大顶堆排序 int i; //首先将无序数列转换为大顶堆 for (i = n / 2; i &gt; 0;i--) //注意由于是完全二叉树，所以我们从一半向前构造，传入父节点 HeapAdjust(k, i, n); //上面大顶堆已经构造完成，我们现在需要排序，每次将最大的元素放入最后，然后将剩余元素重新构造大顶堆，将最大元素放在剩余最后 for (i = n; i &gt;1;i--)&#123; swap(k, 1, i); HeapAdjust(k, 1, i - 1); &#125;&#125; 4.二分： 123456789int getkey (int* a, int key, int low, int high)&#123; int mid = (low+high)/2; if (low&gt;high) return -1; if (a[mid]==key) return mid; else if (a[mid]&lt;key) return getkey(a,key,mid+1,high); else return getkey(a,key,low,mid-1);&#125; 四.图类1.DFS：(普遍递归就行了。。) 12345678910111213141516public void DFSWithStack(TreeNode root) &#123; if (root != null) return; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); stack.push(root); while (!stack.isEmpty()) &#123; TreeNode treeNode = stack.pop(); //在这里处理遍历到的TreeNode if (treeNode.right != null) stack.push(treeNode.right); if (treeNode.left != null) stack.push(treeNode.left); &#125;&#125; 2.BFS： 12345678910111213public void BFSWithQueue(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if (root != null) queue.add(root); while (!queue.isEmpty()) &#123; TreeNode treeNode = queue.poll(); //在这里处理遍历到的TreeNode节点 if (treeNode.left != null) queue.add(treeNode.left); if (treeNode.right != null) queue.add(treeNode.right); &#125;&#125; 五.基础算法1.全排列： 12345678910private static void permutation(int[] array, int index) &#123; if (index == array.length - 1) System.out.println(Arrays.toString(array)); for (int i = index; i &lt; array.length; i++) &#123; swap(array, i, index); permutation(array, index + 1); swap(array, i, index); &#125; &#125; 2.数组子集： 12345678res = []for i in range(1&lt;&lt;len(nums)):# 子集总共有多少个集合 tmp = [] for j in range(len(nums)):# 当前子集集合的生成 if i &amp; 1 &lt;&lt; j: # 当前子集集合包含第j字符的判断 tmp.append(nums[j]) res.append(tmp)return res 3.极大数相加相减相乘：（不想写 六.贪心和DP 七.位运算类 八.数组类]]></content>
  </entry>
  <entry>
    <title><![CDATA[中兴小准备]]></title>
    <url>%2F2019%2F09%2F11%2F%E4%B8%AD%E5%85%B4%E5%B0%8F%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[1.如何防止SQL注入攻击：不要使用动态SQL、不要将敏感数据保留在纯文本、限制数据库权限和特权、避免直接向用户显示数据库错误、对访问数据库的Web应用程序使用Web应用程序防火墙（WAF）、定期测试与数据库交互的Web应用程序。2.OSI七层协议： 物理层；数据链路层，对电信号（数据包）分组，源和目标地址都是mac地址，局域网广播；网络层，IP协议，IP地址标识在哪个局域网；传输层，TCP协议和UDP协议，建立端口到端口的通信；会话层，表示层，定义数据格式以及加密；应用层，规定应用程序的数据格式，HTTP。3.如果不是路由器，是交换机网段要相同吗：不。4.HTTP状态码：1信息，2成功，3重定向，4客户端错误，5服务器错误。5.TCP半连接：6.TCP/IP：网络接口层、网络、传输、应用。7.路由器算法协议：8.线程进程，具体资源：线程共享资源：地址空间、全局变量、打开文件、子进程、信号；进程独享资源：程序计数器、寄存器、栈、状态字。9.ACID：A不可分割，要么操作要么不做；C事务前后数据完整性一致；I多个用户并发访问，多个并发事务相互隔离；D改变永久。10.单例模式实现：懒汉直接初始化，饿汉用才创建。11.全局变量存放在堆，临时变量存放在栈 没然后静态变量存放在方法区。12.TCP拥塞控制机制：端到端拥塞控制，通过报文丢失认为网络出现拥塞，缩减拥塞窗口减小发送速率；慢启动、拥塞避免、快重传和快速恢复。13.创建线程方式：Thread,Runnable,Callable,使用Executor框架来创建线程池。]]></content>
  </entry>
  <entry>
    <title><![CDATA[小红书问答]]></title>
    <url>%2F2019%2F09%2F11%2F%E5%B0%8F%E7%BA%A2%E4%B9%A6%E9%97%AE%E7%AD%94%2F</url>
    <content type="text"><![CDATA[1.怎么使一个类不被继承：final（其他用法）2.讲讲voletile3.讲讲项目springboot框架 4.手撕全排列5.手撕极大数相加6.手撕极大数相减7.手撕BFS8.JMM9.OSI七层协议10.A类地址11.]]></content>
  </entry>
  <entry>
    <title><![CDATA[小红书之前的小准备]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%B0%8F%E7%BA%A2%E4%B9%A6%E4%B9%8B%E5%89%8D%E7%9A%84%E5%B0%8F%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[1.进程和线程的区别：2.hashmap不安全原因:put的addEntry和扩容，都不同步。3.hashtable线程安全实现：synchronized来保证线程安全 4.concurrenthashmap线程安全实现：Segment数组结构和HashEntry数组结构组成，Segment是一种可重入锁ReentrantLock，ashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。5.final和fianlly区别：final修饰不能被继承的类、锁定方法、修饰变量使它称为常量。finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块。6.JVM的存储方式：方法区:存储的是类的定义,静态数据,常量池,由jvm来控制管理堆区:数组申请的空间,对象申请的空间,总之new出来的空间，堆空间中存储的是数组数据,对象的数据,可以通过程序操作的栈区:堆中的对象空间中存储的是属性数据,没有方法,判断对象是否相等,主要判断的是对象中的属性的值是否相等，所以对象就是数据的载体,对象中没有方法,只有数据，通过对象打点调用方法,实际上使用的方法区中的类定义里方法，方法中使用哪个对象的数据,取决于方法是被哪个对象调用的]]></content>
  </entry>
  <entry>
    <title><![CDATA[瓜子小准备和问题和招银问题]]></title>
    <url>%2F2019%2F09%2F06%2F%E7%93%9C%E5%AD%90%E5%89%8D%E7%9A%84%E5%B0%8F%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[先说招银电面问题叭1.讲对控制反转和依赖插入的理解。2.JAVA中线程实现的方法。3.hashmap的理解、对线程安全的理解、hashmap的线程安全具体实现。4.final和finally差异。 瓜子小问题 瓜子小准备1.socket编程函数：服务器：socket()创建；bind()绑定IP、端口；listen()设置最大连接；accept()接受客户端连接；send()recv()收发data；客户端：socket()；bind()；connect();send()recv();2.死锁：互斥、请求与保持、不可剥夺、环路等待。3.LRU：最近最少使用。链表，最新放尾部，最近访问放尾部，删表头。实现，LinkedHashMap,removeEldestEntry.4.进程间通信：临界区、事件、信号量、互斥量。进程内存独有。 线程间通信：全局变量、Message、CEvent。线程内存共享，CPU调度分配最小单位。5.稳定：插冒归基。不稳：希选堆快。6.进程切换：虚拟内存。shutdown:howto值，0读1写2读写；close：立即关，对别的开。7.服务器共享session：MySQL、通过cookie、redis、还有个啥来着。8.进程调度：FCFS、短作业优先、优先权、时间片、高相应比（响应时间/需求服务时间）。9.运行–&gt;阻塞–&gt;(sleep.join)就绪–&gt;运行；运行–(wait)等待；运行–锁池；锁池–就绪。10.垃圾回收（？）：复制、标记整理、标记清除、引用计数、分代。11.LinuxL:看内存atop、ntop(实时内存)、free；网络状态netstat；磁盘空间df；tail日志跟新；top资源占用；grep字符串匹配；sudo授权。]]></content>
  </entry>
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <url>%2F2019%2F08%2F21%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[也不是我写的啦，看到的简单记录下最优解法，68个都记一下吧。先一半。3.数组中重复数字： 将值为i的元素调整到第i个位置求解。4.二维数组查找： 从右上角开始，小于它的数在其左边，大于它的数在其右边。5.空格替换： 两个指针从最右边遍历，遇到空格填充替换字符。6.逆序打印链表： 递归、头插法、栈。7.根据前序遍历和中序遍历重建二叉树（不含重复数）： 前序第一个值为根，把中序分两部分。 private Map&lt;Integer, Integer&gt; indexForInOrders = new HashMap&lt;&gt;();8.给定二叉树和一个节点，找其中序遍历下一个节点(节点有指向父节点指针): 右子树不为空，为右子树最左节点；否则向上找第一个左链接指向的树包含该节点的祖先节点。9.两个栈实现队列： 一个处理push，另一个处理pop，出的时候先进pop再出。10.斐波那契数列：用数组缓存一下计算过的数据。 n个21矩形覆盖一个2n，几种方法；跳台阶（1or2步）：找递推公式。 变态跳台阶（1or2or…n步）：等比数列f(n) = 2f(n-1)；动态规划。11.输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素： 用改良二分法，将数组一分为二，一个是包含最小元素的新旋转数组，另一个是非递减排序的数组（第一个元素一个小于等于最后一个元素），多次二分即可。12.字符矩阵路径： 回溯法（暴力搜索）。13.机器人运动范围： 回溯深搜。14.一根升子剪多段，每段长度乘积最大： 贪心，优先3、2；动态规划。15.输出一个数二进制表示中1的个数： n&amp;(n-1)位运算，每做一次ans++，至0。16.base（浮点数） 的 exponent（整数） 次方： (xx)n/可以递归求解。17.打印从1到最大n位数： char数组存储数字，回溯法得到所有数。18.O(1)时间删除链表节点（删重复节点类似）： 非尾节点，将下一个节点值给它，把下一个删了；尾节点则将它前面一个节点指向null。19.正则表达式匹配（.一个，a任意个a）： dp[0][0] = true; for (int i = 1; i &lt;= n; i++) if (pattern[i - 1] == ‘‘) dp[0][i] = dp[0][i - 2]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (str[i - 1] == pattern[j - 1] || pattern[j - 1] == &apos;.&apos;) dp[i][j] = dp[i - 1][j - 1]; else if (pattern[j - 1] == &apos;*&apos;) if (pattern[j - 2] == str[i - 1] || pattern[j - 2] == &apos;.&apos;) { dp[i][j] |= dp[i][j - 1]; // a* counts as single a dp[i][j] |= dp[i - 1][j]; // a* counts as multiple a dp[i][j] |= dp[i][j - 2]; // a* counts as empty } else dp[i][j] = dp[i][j - 2]; // a* only counts as empty20.表示数值的字符串： 正则表达式匹配，return new String(str).matches(“[+-]?\d*(\.\d+)?([eE][+-]?\d+)?”); [] ： 字符集合 () ： 分组 ? ： 重复 0 ~ 1 次 + ： 重复 1 ~ n 次 * ： 重复 0 ~ n 次 . ： 任意字符 \. ： 转义后的 . \d ： 数字21.调整数组顺序使奇数位于偶数前面： 创新数组或者冒泡。22.链表中倒数第 K 个结点： 设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，再同时移动。23.链表中环的入口结点： 一个指针每次移动两个，另一个指针每次移动一个，存在环必定相遇，此点即入口。24.反转链表： 递归，或者头插法迭代。25.合并两个排序的链表： 递归或者迭代。26.树的子结构：]]></content>
  </entry>
  <entry>
    <title><![CDATA[网易严选面试前的小准备]]></title>
    <url>%2F2019%2F08%2F17%2F%E7%BD%91%E6%98%93%E4%B8%A5%E9%80%89%E9%9D%A2%E8%AF%95%E5%89%8D%E7%9A%84%E5%B0%8F%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[1.string不可变，string buffer和string builder可变；string builder非线性安全，其余两个线性安全。2.输入域名到看到页面过程：域名解析成IP，TCP三次握手，发送HTTP请求，处理请求返回HTTP报文，四次挥手。 3.JAVA内存模型：JAVA虚拟机=线程栈+堆，每个线程都有自己的线程栈，所有的创建对象放在堆里，所有原始类型的本地变量和调用栈放线程栈中。 硬件内存模型与JAVA内存模型的一致性：CPU缓存和指令重排。 synchronized volatile4.MySQL索引：普通index，唯一primary key &amp; unique.，联合，全文fulltext，空间。 hash索引适合等值查询，B+树适合范围查询。B+树比B树查询效率平均。5.error程序本身无法解决，exception程序本身可以解决。6.kafka消息丢失问题：开启重试 or 配置acks = all。7.hashmap:数组和链表，散列桶，存储键值对。8.hashmap 效率高但是线程不安全，hashtable和concurrenthashmap线程安全；hashset存储对象。9.vector同步，arraylist不同步。10.concurrenthashmap线程安全：数据分一段一段，每段一把锁。11.synchronized解决多线程访问资源同步性，它和reentrantlock都是可重入，前者依赖JVM，后者依赖高级API。12.线程把变量保存到本地内存，而主存可以更改数据，这会导致数据不一致。13.volatile修饰变量，它不会阻塞，有可见性，没有原子性；synchronized修饰方法和代码块，与前者相反。14.JUC原子类：基本，数组，引用，对象属性修改。15.AQS构建锁和同步器，使用CLH队列锁。16.集合类：list和set继承collection，map继承map。17.redis：string，hash，list，set，sorted set。淘汰机制。过期时间。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F17%2FHello-World%2F</url>
    <content type="text"><![CDATA[hello world!]]></content>
  </entry>
</search>
