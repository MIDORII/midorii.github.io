<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[华为前的小准备]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%8D%8E%E4%B8%BA%E5%89%8D%E7%9A%84%E5%B0%8F%E5%87%86%E5%A4%87%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[操作系统的小小集合]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B0%8F%E5%B0%8F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络的小小总结]]></title>
    <url>%2F2019%2F09%2F15%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%B0%8F%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[手撕代码基础]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[链表类：二叉树类：排序类：位运算类：数组类：搜索类：dp类：]]></content>
  </entry>
  <entry>
    <title><![CDATA[中兴小准备]]></title>
    <url>%2F2019%2F09%2F11%2F%E4%B8%AD%E5%85%B4%E5%B0%8F%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[1.如何防止SQL注入攻击：不要使用动态SQL、不要将敏感数据保留在纯文本、限制数据库权限和特权、避免直接向用户显示数据库错误、对访问数据库的Web应用程序使用Web应用程序防火墙（WAF）、定期测试与数据库交互的Web应用程序。2.OSI七层协议： 物理层；数据链路层，对电信号（数据包）分组，源和目标地址都是mac地址，局域网广播；网络层，IP协议，IP地址标识在哪个局域网；传输层，TCP协议和UDP协议，建立端口到端口的通信；会话层，表示层，定义数据格式以及加密；应用层，规定应用程序的数据格式，HTTP。3.如果不是路由器，是交换机网段要相同吗：不。4.HTTP状态码：1信息，2成功，3重定向，4客户端错误，5服务器错误。5.TCP半连接：6.TCP/IP：网络接口层、网络、传输、应用。7.路由器算法协议：8.线程进程，具体资源：线程共享资源：地址空间、全局变量、打开文件、子进程、信号；进程独享资源：程序计数器、寄存器、栈、状态字。9.ACID：A不可分割，要么操作要么不做；C事务前后数据完整性一致；I多个用户并发访问，多个并发事务相互隔离；D改变永久。10.单例模式实现：懒汉直接初始化，饿汉用才创建。11.全局变量存放在堆，临时变量存放在栈 没然后静态变量存放在方法区。12.TCP拥塞控制机制：端到端拥塞控制，通过报文丢失认为网络出现拥塞，缩减拥塞窗口减小发送速率；慢启动、拥塞避免、快重传和快速恢复。13.创建线程方式：Thread,Runnable,Callable,使用Executor框架来创建线程池。]]></content>
  </entry>
  <entry>
    <title><![CDATA[小红书问答]]></title>
    <url>%2F2019%2F09%2F11%2F%E5%B0%8F%E7%BA%A2%E4%B9%A6%E9%97%AE%E7%AD%94%2F</url>
    <content type="text"><![CDATA[1.怎么使一个类不被继承：final（其他用法）2.讲讲voletile3.讲讲项目springboot框架 4.手撕全排列5.手撕极大数相加6.手撕极大数相减7.手撕BFS8.JMM9.OSI七层协议10.A类地址11.]]></content>
  </entry>
  <entry>
    <title><![CDATA[小红书之前的小准备]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%B0%8F%E7%BA%A2%E4%B9%A6%E4%B9%8B%E5%89%8D%E7%9A%84%E5%B0%8F%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[1.进程和线程的区别：2.hashmap不安全原因:put的addEntry和扩容，都不同步。3.hashtable线程安全实现：synchronized来保证线程安全 4.concurrenthashmap线程安全实现：Segment数组结构和HashEntry数组结构组成，Segment是一种可重入锁ReentrantLock，ashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。5.final和fianlly区别：final修饰不能被继承的类、锁定方法、修饰变量使它称为常量。finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块。6.JVM的存储方式：方法区:存储的是类的定义,静态数据,常量池,由jvm来控制管理堆区:数组申请的空间,对象申请的空间,总之new出来的空间，堆空间中存储的是数组数据,对象的数据,可以通过程序操作的栈区:堆中的对象空间中存储的是属性数据,没有方法,判断对象是否相等,主要判断的是对象中的属性的值是否相等，所以对象就是数据的载体,对象中没有方法,只有数据，通过对象打点调用方法,实际上使用的方法区中的类定义里方法，方法中使用哪个对象的数据,取决于方法是被哪个对象调用的7.链表倒置：‘’’JAVALinkNode prev = null;LinkNode next = null;while (node != null){next = node.next;node.next = prev;prev = node;node = next;}return prev;‘’’8.数组子集：‘’’JAVAres = []for i in range(1&lt;&lt;len(nums)):# 子集总共有多少个集合 tmp = [] for j in range(len(nums)):# 当前子集集合的生成 if i &amp; 1 &lt;&lt; j: # 当前子集集合包含第j字符的判断 tmp.append(nums[j]) res.append(tmp)return res‘’’9.链表快排：‘’’pNode* partition(pNode* start,pNode* end){ int num = start-&gt;val; pNode* p = start; pNode* q = start-&gt;next; while(q != end){ if(q-&gt;val &lt; num){ p = p-&gt;next; swap(p-&gt;val,q-&gt;val); } q = q-&gt;next; } swap(p-&gt;val,start-&gt;val); return p;}void quick_sort(pNode* start,pNode* end){ if(start != end){ pNode* index = partition(start,end); quick_sort(start,index); quick_sort(index-&gt;next,end); }}‘’’10.快排:‘’’JAVAvoid quickSort(vector &amp;num, int l, int r) { if (l &gt;= r) //先检查左右条件 return; int i = l, j = r, x = num[l]; while (i &lt; j) { while (i &lt; j &amp;&amp; num[j] &gt;= x)//从右向左找到第一个小于x的 j–; if (i &lt; j) num[i++] = num[j];//填坑之后i++ while (i &lt; j &amp;&amp; num[i] &lt;= x)//从左向右找第一个大于x的数 i++; if (i &lt; j) num[j–] = num[i]; } num[i] = x; //把最开始取出来的x放到i处 quickSort(num, l, i - 1);//以i为中间值，分左右两部分递归调用 quickSort(num, i + 1, r);}‘’’ 手撕链表的最基本操作：‘’’JAVAtype struct Node{ int num; struct Node *next;}node;//INSERT p = (LinkList)malloc(sizeof(LNode)); p-&gt;next = x ; p-&gt;next = l-&gt;next; l-&gt;next = p; //DELETE p = L; while() p = p-&gt;next; q = p-&gt;next;p-&gt;next=q-&gt;next; free(q); ‘’’]]></content>
  </entry>
  <entry>
    <title><![CDATA[瓜子小准备和问题和招银问题]]></title>
    <url>%2F2019%2F09%2F06%2F%E7%93%9C%E5%AD%90%E5%89%8D%E7%9A%84%E5%B0%8F%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[先说招银电面问题叭1.讲对控制反转和依赖插入的理解。2.JAVA中线程实现的方法。3.hashmap的理解、对线程安全的理解、hashmap的线程安全具体实现。4.final和finally差异。 瓜子小问题 瓜子小准备1.socket编程函数：服务器：socket()创建；bind()绑定IP、端口；listen()设置最大连接；accept()接受客户端连接；send()recv()收发data；客户端：socket()；bind()；connect();send()recv();2.死锁：互斥、请求与保持、不可剥夺、环路等待。3.LRU：最近最少使用。链表，最新放尾部，最近访问放尾部，删表头。实现，LinkedHashMap,removeEldestEntry.4.进程间通信：临界区、事件、信号量、互斥量。进程内存独有。 线程间通信：全局变量、Message、CEvent。线程内存共享，CPU调度分配最小单位。5.稳定：插冒归基。不稳：希选堆快。6.进程切换：虚拟内存。shutdown:howto值，0读1写2读写；close：立即关，对别的开。7.服务器共享session：MySQL、通过cookie、redis、还有个啥来着。8.进程调度：FCFS、短作业优先、优先权、时间片、高相应比（响应时间/需求服务时间）。9.运行–&gt;阻塞–&gt;(sleep.join)就绪–&gt;运行；运行–(wait)等待；运行–锁池；锁池–就绪。10.垃圾回收（？）：复制、标记整理、标记清除、引用计数、分代。11.LinuxL:看内存atop、ntop(实时内存)、free；网络状态netstat；磁盘空间df；tail日志跟新；top资源占用；grep字符串匹配；sudo授权。]]></content>
  </entry>
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <url>%2F2019%2F08%2F21%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[也不是我写的啦，看到的简单记录下最优解法，68个都记一下吧。先一半。3.数组中重复数字： 将值为i的元素调整到第i个位置求解。4.二维数组查找： 从右上角开始，小于它的数在其左边，大于它的数在其右边。5.空格替换： 两个指针从最右边遍历，遇到空格填充替换字符。6.逆序打印链表： 递归、头插法、栈。7.根据前序遍历和中序遍历重建二叉树（不含重复数）： 前序第一个值为根，把中序分两部分。 private Map&lt;Integer, Integer&gt; indexForInOrders = new HashMap&lt;&gt;();8.给定二叉树和一个节点，找其中序遍历下一个节点(节点有指向父节点指针): 右子树不为空，为右子树最左节点；否则向上找第一个左链接指向的树包含该节点的祖先节点。9.两个栈实现队列： 一个处理push，另一个处理pop，出的时候先进pop再出。10.斐波那契数列：用数组缓存一下计算过的数据。 n个21矩形覆盖一个2n，几种方法；跳台阶（1or2步）：找递推公式。 变态跳台阶（1or2or…n步）：等比数列f(n) = 2f(n-1)；动态规划。11.输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素： 用改良二分法，将数组一分为二，一个是包含最小元素的新旋转数组，另一个是非递减排序的数组（第一个元素一个小于等于最后一个元素），多次二分即可。12.字符矩阵路径： 回溯法（暴力搜索）。13.机器人运动范围： 回溯深搜。14.一根升子剪多段，每段长度乘积最大： 贪心，优先3、2；动态规划。15.输出一个数二进制表示中1的个数： n&amp;(n-1)位运算，每做一次ans++，至0。16.base（浮点数） 的 exponent（整数） 次方： (xx)n/可以递归求解。17.打印从1到最大n位数： char数组存储数字，回溯法得到所有数。18.O(1)时间删除链表节点（删重复节点类似）： 非尾节点，将下一个节点值给它，把下一个删了；尾节点则将它前面一个节点指向null。19.正则表达式匹配（.一个，a任意个a）： dp[0][0] = true; for (int i = 1; i &lt;= n; i++) if (pattern[i - 1] == ‘‘) dp[0][i] = dp[0][i - 2]; for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (str[i - 1] == pattern[j - 1] || pattern[j - 1] == &apos;.&apos;) dp[i][j] = dp[i - 1][j - 1]; else if (pattern[j - 1] == &apos;*&apos;) if (pattern[j - 2] == str[i - 1] || pattern[j - 2] == &apos;.&apos;) { dp[i][j] |= dp[i][j - 1]; // a* counts as single a dp[i][j] |= dp[i - 1][j]; // a* counts as multiple a dp[i][j] |= dp[i][j - 2]; // a* counts as empty } else dp[i][j] = dp[i][j - 2]; // a* only counts as empty20.表示数值的字符串： 正则表达式匹配，return new String(str).matches(“[+-]?\d*(\.\d+)?([eE][+-]?\d+)?”); [] ： 字符集合 () ： 分组 ? ： 重复 0 ~ 1 次 + ： 重复 1 ~ n 次 * ： 重复 0 ~ n 次 . ： 任意字符 \. ： 转义后的 . \d ： 数字21.调整数组顺序使奇数位于偶数前面： 创新数组或者冒泡。22.链表中倒数第 K 个结点： 设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，再同时移动。23.链表中环的入口结点： 一个指针每次移动两个，另一个指针每次移动一个，存在环必定相遇，此点即入口。24.反转链表： 递归，或者头插法迭代。25.合并两个排序的链表： 递归或者迭代。26.树的子结构：]]></content>
  </entry>
  <entry>
    <title><![CDATA[网易严选面试前的小准备]]></title>
    <url>%2F2019%2F08%2F17%2F%E7%BD%91%E6%98%93%E4%B8%A5%E9%80%89%E9%9D%A2%E8%AF%95%E5%89%8D%E7%9A%84%E5%B0%8F%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[1.string不可变，string buffer和string builder可变；string builder非线性安全，其余两个线性安全。2.输入域名到看到页面过程：域名解析成IP，TCP三次握手，发送HTTP请求，处理请求返回HTTP报文，四次挥手。 3.JAVA内存模型：JAVA虚拟机=线程栈+堆，每个线程都有自己的线程栈，所有的创建对象放在堆里，所有原始类型的本地变量和调用栈放线程栈中。 硬件内存模型与JAVA内存模型的一致性：CPU缓存和指令重排。 synchronized volatile4.MySQL索引：普通index，唯一primary key &amp; unique.，联合，全文fulltext，空间。 hash索引适合等值查询，B+树适合范围查询。B+树比B树查询效率平均。5.error程序本身无法解决，exception程序本身可以解决。6.kafka消息丢失问题：开启重试 or 配置acks = all。7.hashmap:数组和链表，散列桶，存储键值对。8.hashmap 效率高但是线程不安全，hashtable和concurrenthashmap线程安全；hashset存储对象。9.vector同步，arraylist不同步。10.concurrenthashmap线程安全：数据分一段一段，每段一把锁。11.synchronized解决多线程访问资源同步性，它和reentrantlock都是可重入，前者依赖JVM，后者依赖高级API。12.线程把变量保存到本地内存，而主存可以更改数据，这会导致数据不一致。13.volatile修饰变量，它不会阻塞，有可见性，没有原子性；synchronized修饰方法和代码块，与前者相反。14.JUC原子类：基本，数组，引用，对象属性修改。15.AQS构建锁和同步器，使用CLH队列锁。16.集合类：list和set继承collection，map继承map。17.redis：string，hash，list，set，sorted set。淘汰机制。过期时间。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F17%2FHello-World%2F</url>
    <content type="text"><![CDATA[hello world!]]></content>
  </entry>
</search>
