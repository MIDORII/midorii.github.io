<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <url>%2F2019%2F08%2F21%2F%E5%89%91%E6%8C%87offer%2F</url>
    <content type="text"><![CDATA[也不是我写的啦，看到的记录下最优解法。3.数组中重复数字： 将值为i的元素调整到第i个位置求解。4.二维数组查找： 从右上角开始，小于它的数在其左边，大于它的数在其右边。5.空格替换： 两个指针从最右边遍历，遇到空格填充替换字符。6.逆序打印链表： 递归、头插法、栈。7.根据前序遍历和中序遍历重建二叉树（不含重复数）： 前序第一个值为根，把中序分两部分。 private Map&lt;Integer, Integer&gt; indexForInOrders = new HashMap&lt;&gt;();8.给定二叉树和一个节点，找其中序遍历下一个节点(节点有指向父节点指针): 右子树不为空，为右子树最左节点；否则向上找第一个左链接指向的树包含该节点的祖先节点。9.两个栈实现队列： 一个处理push，另一个处理pop，出的时候先进pop再出。10.斐波那契数列：用数组缓存一下计算过的数据。 n个21矩形覆盖一个2n，几种方法；跳台阶（1or2步）：找递推公式。 变态跳台阶（1or2or…n步）：等比数列f(n) = 2*f(n-1)；动态规划。11.输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素： 用改良二分法，将数组一分为二，一个是包含最小元素的新旋转数组，另一个是非递减排序的数组（第一个元素一个小于等于最后一个元素），多次二分即可。12.字符矩阵路径： 回溯法（暴力搜索）。13.机器人运动范围： 回溯深搜。14.一根升子剪多段，每段长度乘积最大： 贪心，优先3、2；动态规划。15.输出一个数二进制表示中1的个数： n&amp;(n-1)位运算，每做一次ans++，至0。16.base（浮点数） 的 exponent（整数） 次方：]]></content>
  </entry>
  <entry>
    <title><![CDATA[严选和猿辅导的查缺补漏]]></title>
    <url>%2F2019%2F08%2F18%2F%E7%BD%91%E6%98%93%E4%B8%A5%E9%80%89%E7%9A%84%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[1.2.]]></content>
  </entry>
  <entry>
    <title><![CDATA[网易严选面试前的小准备]]></title>
    <url>%2F2019%2F08%2F17%2F%E7%BD%91%E6%98%93%E4%B8%A5%E9%80%89%E9%9D%A2%E8%AF%95%E5%89%8D%E7%9A%84%E5%B0%8F%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[1.string不可变，string buffer和string builder可变；string builder非线性安全，其余两个线性安全。2.输入域名到看到页面过程：域名解析成IP，TCP三次握手，发送HTTP请求，处理请求返回HTTP报文，四次挥手。3.JAVA内存模型：JAVA虚拟机=线程栈+堆，每个线程都有自己的线程栈，所有的创建对象放在堆里，所有原始类型的本地变量和调用栈放线程栈中。 硬件内存模型与JAVA内存模型的一致性：CPU缓存和指令重排。 synchronized volatile4.MySQL索引：普通index，唯一primary key &amp; unique.，联合，全文fulltext，空间。 hash索引适合等值查询，B+树适合范围查询。B+树比B树查询效率平均。5.error程序本身无法解决，exception程序本身可以解决。6.kafka消息丢失问题：开启重试 or 配置acks = all。7.hashmap:数组和链表，散列桶，存储键值对。8.hashmap 效率高但是线程不安全，hashtable和concurrenthashmap线程安全；hashset存储对象。9.vector同步，arraylist不同步。10.concurrenthashmap线程安全：数据分一段一段，每段一把锁。11.synchronized解决多线程访问资源同步性，它和reentrantlock都是可重入，前者依赖JVM，后者依赖高级API。12.线程把变量保存到本地内存，而主存可以更改数据，这会导致数据不一致。13.volatile修饰变量，它不会阻塞，有可见性，没有原子性；synchronized修饰方法和代码块，与前者相反。14.JUC原子类：基本，数组，引用，对象属性修改。15.AQS构建锁和同步器，使用CLH队列锁。16.集合类：list和set继承collection，map继承map。17.redis：string，hash，list，set，sorted set。淘汰机制。过期时间。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F17%2FHello-World%2F</url>
    <content type="text"><![CDATA[hello world!]]></content>
  </entry>
</search>
